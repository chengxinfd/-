# C语言

<font color=#FF6347 size=5 face="黑体">**1.static的用法**</font>

+ **作用于函数局部变量**

    特点：初始化为0，运行一开始开辟内存，内存放在全局，增加了变量的存活时间

+ **作用于全局函数**

​		特点：静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可定义相同变量名，两者互不影响	

+ **作用于全局变量**

​		特点：静态函数只能在声明它的文件中可见，其他文件不能引用该函数，其他文件函数名可相同，互不影响

----------------

<font color=#FF6347 size=5 face="黑体">**2.volatile的用法**</font>

​	因为访问寄存器要比访问内存单元快的多，所以编译器一般都会做减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用volatile，则编译器将对所声明的语句进行优化。

​	简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。

​	**面试常问：**

​	①一个参数既可以是const还可以是volatile吗？

​	答：是的。一个例子是只读寄存器状态。它是volatile因为它可能被意向不到地改变，它是const因为程序不应该试图去修改它。

​	②一个指针可以是volatile吗？

​	答：是的。一个例子是当一个中断服务子程序修改指向一个buffer的指针时。

------------

<font color=#FF6347 size=5 face="黑体">**3.const的用法**</font>

* const修饰变量

    > ①修饰的变量可以认为只有只读属性
    >
    > ②在声明时必须对其进行初始化

* const修饰指针变量

    > ① int *const p; 该语句表示指向整形的**常量指针**，它不能在指向别的变量，但指向变量的值可以修改
    >
    > ② const int *p; 该语句表示指向整形常量的**指针**，它的指向可以修改，指向常量的值不能修改
    >
    > ③ int const *p; 该语句和②相同
    >
    > ④ const int * const p; 该语句表示指向整形常量的常量指针。既不能改变指向也不能改变指向的值
    >
    > ⑤ int const * const p;  该语句与④相同

* const修饰函数形参

    >通常用于参数为指针或引用的情况，且只能修饰输入参数

* const修饰函数返回值

    > 使用情况较少

-----

<font color=#FF6347 size=5 face="黑体">**4.堆栈队列**</font>

+ 堆

    > ①堆是特殊的“队列”，从堆中取出元素是按照**元素优先级大小**，而不是元素进入的先后
    >
    > ②堆是一颗完全二叉树，其结点的值大于或小于其子结点的值（大于是最大堆，小于是最小堆）

+ 栈

    > 一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除的一端称为栈顶，另一端称为栈底，遵循**先进后出**

+ 队列

    > 队列是一种操作受限的线性表，是指只允许在固定的一端进行插入的数据结构，遵循**先进先出**

----

<font color=#FF6347 size=5 face="黑体">**5.大端小端**</font>

​	16进制数：unsigned int value = 0x12345678    保存在 unsigned char buf[3]中

+ **大端**

|buf[0]| 0x12 |
|:---:|:---:|
|buf[1]| 0x34 |
|buf[2]| 0x56 |
|buf[3 | 0x78 |

+ **小端**
|buf[0]| 0x78 |
|:---:|:---:|
|buf[1]| 0x56 |
|buf[2]| 0x34 |
|buf[3 | 0x12 |

---

<font color=#FF6347 size=5 face="黑体">**6.结构体对齐**</font>

```c
struct A {
char a; //1
char b; //1
char c; //1
};
//进行整体对齐，最大类型为1<对齐系数4，按1整体对齐，所以1+1+1=3 

struct B {
int a;  //4
char b; //1
short c;//2
};
//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐4 1+2=3<4 对齐4 所以4+4=8 

struct C {
char b; //1
int a;  //4
short c;//2
};
//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐 1<4（对齐4） 4=4 2<4(对齐4)  所以4+4+4=12 

#pragma pack(2)
struct D {
char b; //1
int a;  //4
short c;//2
};
//进行整体对齐，最大类型为4>对齐系数n(2)，所以按2整体对齐 1<2（对齐2）4>2(2的倍数) 2=2 所以2+4+2=8 
```

```c
有一个如下的结构体：
struct A{
 long a1;
 short a2;
 int a3;
 int *a4;
};
请问在64位编译器下用sizeof(struct A)计算出的大小是多少？

 
答案及解析：24
64位编译器下：指针8字节（一定不能忘记），题目不说默认4字节对齐
long a1;   //8
short a2;  //2 8+2=10（不是4的倍数）对齐到4的倍数12
int a3;    //4 4+12=16（4的倍数）
int *a4;   //8 8+16=24（4的倍数）
```

---

<font color=#FF6347 size=5 face="黑体">**7.段**</font>

+ 代码段：代码段就是程序中的可执行部分，直观理解代码段就是函数堆积组成的
+ 数据段：数据段就是程序中的数据，直观理解就是C语言程序中的全局变量